# README for the Interpreter

## General Information

This interpreter, inspired by Lua syntax, allows you to execute mathematical expressions, functions, and commands. It supports multiple statements per line separated by `;`. Functions are called with `functionName(param1, param2, ...)`, while commands use the syntax `COMMAND "parameter"`. Use the `HELP` command to see all available commands.

## Requirements and Compilation

- **GCC**: gcc (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0
- **Flex**: 2.6.4
- **Bison**: (GNU Bison) 3.5.1
- **Operating System**: Ubuntu 20.04.2 LTS

### Installation and Compilation

1. **Make Installation**: You need to have `make` installed. If you don't have it, install it with:
   ```bash
   sudo apt-get install make
   ```

2. **Bison Compilation**: The project uses a `.h` file generated by bison, so it is **NECESSARY** to compile bison with the `-d` option:
   ```bash
   bison -d parser.y
   ```
   **Note**: If you modify the `parser.y` filename, you must correspondingly update the inclusion of the generated `.h` file in the source codes.

3. **Flex Compilation**: To compile the flex file (`flexfile.l`), execute:
   ```bash
   flex flexfile.l
   ```

4. **Project Compilation**: The project includes a Makefile. To compile, execute:
   ```bash
   make
   ```

## Key Features

### Syntax
- **Functions**: `functionName(param1, param2, ...)`
- **Commands**: `COMMAND "parameter"`
- **Expressions**: The interpreter supports a variety of mathematical expressions and operations, including:
  - **Numbers**: Direct numeric values, e.g., `3.14`
  - **Variables**: Identifiers that can store numeric values. Values can be assigned using the syntax `variable = expression`, e.g., `x = 5`
  - **Constants**: Predefined identifiers with fixed numeric values that cannot be reassigned, e.g., `PI_0` and `E_0`
  - **Functions**: Calls to predefined or user-imported functions with the syntax `functionName(param1, param2, ...)`. Functions can take 0 to 3 arguments, e.g., `sin(0)`, `max(3, 7)`
  - **Arithmetic Operations**:
    - Addition: `exp + exp`, e.g., `2 + 3`
    - Subtraction: `exp - exp`, e.g., `5 - 2`
    - Multiplication: `exp * exp`, e.g., `4 * 3`
    - Division: `exp / exp`, e.g., `10 / 2` (Note: Division by zero generates an error)
    - Unary negation: `-exp`, e.g., `-5`
    - Exponentiation: `exp ^ exp`, e.g., `2 ^ 3`
    - Grouping: Use of parentheses to group subexpressions, e.g., `(2 + 3) * 4`
    
  The interpreter also handles errors such as:
  - Division by zero
  - Use of undefined variables
  - Attempts to assign values to constants or functions
  - It can import functions from external libraries if they are not defined locally (see `IMPORT` command)

### Parameter System
- Functions are allowed with 0 to 3 parameters. This limit is a feature of a prototype variable argument passing system, since generating function pointers with more parameters dynamically in C goes beyond the scope of standard libraries.
- The number of arguments for a function is not encoded as metadata, so the user must ensure correct calls (appropriate number of parameters) to avoid undefined behavior when calling functions.

### `HELP` Command
- Fundamental for exploring all available commands.

### `IMPORT` Command
- Loads dynamic libraries. Includes a test library: `"libtestfuncs.so"` (compiled from `"testfuncs.c"`).
- Example: `IMPORT "./libtestfuncs.so"`

### `LOAD` Command
- Executes script files. Includes two test files: `"testload1"` and `"testload2"`.
- Example: `LOAD "./testload1"`

### Error Management
- Centralized module with three types of errors: command errors, syntax/semantic errors, and lexical errors.

### Symbol Table
- Uses a Binary Search Tree (BST) as the internal structure, adapted for the new architecture with added deletion functionality mainly for the `CLEAR` command.